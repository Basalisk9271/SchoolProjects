using namespace std;
#include <string>
#include <iomanip>
#include <algorithm>
#include <ctype.h>
#include <stdio.h>
#include <iostream>
#include <sstream>
#include <fstream>
#include <stdlib.h>
#include <cstdlib>
#include "HashTable.h"
#include "graph.h"

struct Node { 
    string vertex;
    int dist;
    string prev;
    bool marked;
}; //Struct for creating objects called 'nodes' to be used in the algorithm function

void readFile(int argc, char *argv[], Graph<string>& myGraph, vector<string>& v, vector<Node>& nodes, int& items);
bool find(vector<string>& v, string& str);
void menu( vector<string>& v, int& items, string& begin);
int findNode(vector<Node>& v, string& str);
int findLowestDist(vector<Node>& v);
void dijkstraAlg(Graph<string>& myGraph, Queue<string>& myQ, vector<Node>& nodes, vector<string>& v, string& begin, int& itemNum);
void printCitiesMenu(vector<string>& v);
void requestStart(vector<string>& v, string& begin, int& items);
void printNodes(vector<Node>& nodes);


int main(int argc, char *argv[])
//Main function that runs the program
{    
    Graph<string> myGraph(50); //Graph to hold the weighted graph generated by the Graph.cpp class
    Queue<string> myQ(50); //Queue for my adjacent vertices; used when comparing the distances between the two
    vector<string> v; //vector to house all of my vertices' names; Useful when selecting things
    vector<Node> nodes; //Vector of Nodes to hold all of the nodes in the order of them being picked. This will help me print the nodes in the table. 
    int items; //Number of vertices
    string begin; //String that holds the beginning location
    readFile(argc, argv, myGraph, v, nodes, items);
    menu(v, items, begin);
    dijkstraAlg(myGraph, myQ, nodes, v, begin, items);
    printNodes(nodes);
}//End Main()

void readFile(int argc, char *argv[], Graph<string>& myGraph, vector<string>& v, vector<Node>& nodes, int& items)
//Function that reads in the file and creates the directed graph that the rest of the program, including the Dijkstra's Algorithm part, 
//will use in some capacity or other.
{
    ifstream fileIn;
    if (argc == 1)
    {
        cout << "\tError -- No Filename Entered!" << endl;
        exit(1);
    }
    string fileName = argv[argc-1];
    fileIn.open(fileName.c_str());

    string origin, dest, lineText, distance, temp;
    //int dist;
    items = 0;
    
    // Use a while loop to read the target file word by word
    while (!fileIn.eof()) {
        // Output the text from the file
        getline(fileIn, origin, ';');
        //if there is nothing on the line, then skip the line
        if (origin == "")
        {
            break;
        }
        getline(fileIn, dest, ';');
        getline(fileIn, distance);
        int dist = atoi(distance.c_str());

        if (find(v, origin) == false)
        {
            v.push_back(origin);
            myGraph.AddVertex(origin);
        }
        if (find(v, dest) == false)
        {
            v.push_back(dest);
            myGraph.AddVertex(dest);
        }

        myGraph.AddEdge(origin, dest, dist);
        
    }
    items = v.size();
    fileIn.close();
}//End readFile()

bool find(vector<string>& v, string& str) //Function that returns whether a desired string is located in a vector of strings
{
    for (int i = 0; i < v.size(); i++)
        if (v[i].compare(str) == 0)
            return true;
    return false;
}//End toLowerCase()

void menu( vector<string>& v, int& items, string& begin) //Menu to run the program and display the cities and the prompt for starting location
{
    system("clear");
    cout << "\n\t^^^^^^^^^^^^^^^^    DIJKSTRA'S ALGORITHM    ^^^^^^^^^^^^^^^^\n\n\tA Weighted Graph Has Been Built For These " << items << " Cities: \n\n";
    printCitiesMenu(v);
    cout << endl;
    requestStart(v, begin, items);
}//End menu()

int findNode(vector<Node>& v, string& str) //Function to return the index number of a node with the desired str in it. 
{
    int index = 0;
    for (int i = 0; i < v.size(); i++)
        if (v[i].vertex == str)
        {
            index = i;
        }
    return index;
}//End findNode()

int findLowestDist(vector<Node>& v)
{
    int min = __INT_MAX__, index;
    for (int i = 0; i < v.size(); i++)
        if (v[i].dist < min && v[i].marked == false)
        {
            min = v[i].dist;
            index = i;
        }
    return index;
}//End findLowestDist()

void dijkstraAlg(Graph<string>& myGraph, Queue<string>& myQ, vector<Node>& nodes, vector<string>& v, string& begin, int& itemNum) 
//function to run the entirety of Dijkstra's algorithm
{
    string curr = begin;
    vector<Node> tempNV;
    string comp, previous;
    Node N;
    int totalDist = 0, lowDist;
    for (int k = 0; k < v.size(); k++)
    {
        N.vertex = v[k];
        N.prev = "N/A";
        N.dist = __INT_MAX__;
        N.marked = false;
        tempNV.push_back(N);
    }
    int find = findNode(tempNV, curr);
    tempNV[find].dist = myGraph.WeightIs(curr, curr);
    tempNV[find].marked = true;
    N = tempNV[find];
    nodes.push_back(N); //pushes starting node to the vector of nodes. 

    int addDist = 0;
    myGraph.GetToVertices(curr, myQ);
    while (nodes.size() < itemNum)  
    {  
        while (!myQ.isEmpty())
        {
            comp = myQ.dequeue();
            find = findNode(tempNV, comp);
            if (tempNV[findNode(tempNV, curr)].prev != "N/A")
            {
                previous = tempNV[findNode(tempNV, curr)].prev;
                string tempP = previous, tempCurr = curr;
                while (tempP != "N/A")
                {
                    totalDist += myGraph.WeightIs(tempP, tempCurr);
                    tempCurr = tempP;
                    tempP = tempNV[findNode(tempNV, tempP)].prev;
                }
                //totalDist += addDist;

            }
                totalDist += myGraph.WeightIs(curr, comp);
            if (tempNV[find].marked == false && totalDist < tempNV[find].dist)
            {
                tempNV[find].dist = totalDist;
                tempNV[find].prev = curr;
                //if the weight from the node to the examined node is less, then replace the one on the node 
                
            }//End if
            totalDist = 0; //Flushing the additional distance for previous paths 
            
        }//End while
        
            
         //finds the index of the node with the lowest unmarked distance. 
        lowDist = findLowestDist(tempNV);
        tempNV[lowDist].marked = true;
        nodes.push_back(tempNV[lowDist]);
        curr = tempNV[lowDist].vertex;
        myGraph.GetToVertices(curr, myQ);        
    }//End while loop  
             

}//End dijkstraAlg()

void printCitiesMenu(vector<string>& v) //Prints the vertices nicely in the menu
{
    int temp = 0;
    for (int i = 0; i < (v.size()/3); i++)
    {
        int j = 0;
        while (j < 3)
        {
            cout << right << setw(20) << v[temp];
            j++;
            temp++;
        }
        cout << endl;

    }
    for (int k = temp+1; k <= v.size(); k++)
    {
        cout << right << setw(20) << v[temp];
    } 
    cout << endl;
}//End printCitiesMenu()

void requestStart(vector<string>& v, string& begin, int& items) 
//Loop to control whether the input is valid or not for the starting point. User gets stuck her unless they put in a valid option
{
    int loop = 0;
    string start = "";
    cout << "\tPlease input your starting vertex: A Weighted Graph Has Been Built For These " << items << " Cities" << endl;
    do 
    {
        
        if (find(v, start) == false)
        {
            cout << "\tStarting location does not exist...\n\tPlease input a new starting vertex: ";
            getline(cin, start);
        }
        else{
            begin = start;
            loop = 1;
        }
    }while(loop != 1);
}//End requestStart()

void printNodes(vector<Node>& nodes) //Prints nodes from a vector of nodes
{
    cout << endl;
    cout << "\t----------------------------------------------------------------" << endl;
    cout << right << setw(20) << "Vertex" << right << setw(20)<< "Distance" << right << setw(20) << "Previous" << endl;
    cout << endl;
    for (int i = 0; i < nodes.size(); i++)
    {
        Node N = nodes[i];
        cout << right << setw(20) << N.vertex << right << setw(20)<< N.dist << right << setw(20) << N.prev << endl;
    }
    cout << endl;
    
    
}//End printNodes()

