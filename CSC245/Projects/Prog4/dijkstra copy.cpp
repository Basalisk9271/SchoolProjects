using namespace std;
#include <string>
#include <algorithm>
#include <ctype.h>
#include <stdio.h>
#include <iostream>
#include <sstream>
#include <fstream>
#include <stdlib.h>
#include <cstdlib>
#include "HashTable.h"
#include "graph.h"
#include <array>

struct Node { 
    string vertex;
    int dist;
    string prev;
};


//void menu(char *argv[], HashTable& dictionary, char& command);
//void buildDictionary (HashTable& dictionary);
void readFile(int argc, char *argv[], Graph<string>& myGraph, vector<string>& v, vector<Node>& nodes, int& items);
bool find(vector<string>& v, string& str);
void menu( vector<string>& v, int& items, string& begin);
void printCitiesMenu(vector<string>& v);
void requestStart(vector<string>& v, string& begin);
void dijkstraAlg(Graph<string>& myGraph, Queue<string>& myQ, vector<Node>& nodes, string& begin, int& itemNum);
void printNodes(vector<Node>& nodes);
int minimumDist(vector<int>& distance, vector<bool>& TFSet, int& itemNum);
void graphToArray (Graph<string>& myGraph, vector<int> g[itemNum][itemNum], int& itemNum, vector<string>& v);
/*void toLowerCase(string& strIn);
void rmSymbols(string& strIn);
void rmNum(string& strIn);
void options (char& command, string& fileText, HashTable& skipped, HashTable& dictionary, int& items, BinarySearchTree<BNode>& notFound);
void addToDict(string& addWord);
void writeFile(BinarySearchTree<BNode>& notFound);
bool dictCheck(string& word, string& suggestion, HashTable& dictionary);*/

int main(int argc, char *argv[])
//Function to run the entire program
{    
    Graph<string> myGraph(50); //Graph to hold the weighted graph generated by the Graph.cpp class
    Queue<string> myQ(50); //Queue for my adjacent vertices; used when comparing the distances between the two
    vector<string> v; //vector to house all of my vertices' names; Useful when selecting things
    vector<Node> nodes; //Vector of Nodes to hold all of the nodes in the order of them being picked. This will help me print the nodes in the table. 
    int items; //Number of vertices
    string begin; //String that holds the beginning location
    //string str1 = "Denver";
    //string str2 = "Denver";

    readFile(argc, argv, myGraph, v, nodes, items);
    menu(v, items, begin);
    vector<int> graph[items][items];
    graphToArray(myGraph, graph, items, v);
    //cout << "\tThe distance from " << str1 << " to " << str2 << " is " << myGraph.WeightIs(str1, str2) << " miles" << endl;
    //dijkstraAlg(myGraph, myQ, nodes, begin, items);
    //printNodes(nodes);
}//End Main()

/*void buildDictionary(HashTable& dictionary)
{
    ifstream dictIn;
   
    string dictName = "dict.txt";
    dictIn.open(dictName.c_str());

    string myText;
    
    // Use a while loop together with the getline() function to read the dictionary line by line
    while (getline (dictIn, myText)) 
    {
        dictionary.insert(myText);
    }

    // Close the dictionary file
    dictIn.close();
}//End buildDictionary()*/


void readFile(int argc, char *argv[], Graph<string>& myGraph, vector<string>& v, vector<Node>& nodes, int& items)
{
    ifstream fileIn;
    if (argc == 1)
    {
        cout << "\tError -- No Filename Entered!" << endl;
        exit(1);
    }
    string fileName = argv[argc-1];
    fileIn.open(fileName.c_str());

    string origin, dest, lineText, distance, temp;
    //int dist;
    items = 0;
    
    // Use a while loop to read the target file word by word
    while (!fileIn.eof()) {
        // Output the text from the file
        getline(fileIn, origin, ';');
        //if there is nothing onn the line, then skip the line
        if (origin == "")
        {
            break;
        }
        getline(fileIn, dest, ';');
        getline(fileIn, distance);
        int dist = atoi(distance.c_str());

        if (find(v, origin) == false)
        {
            v.push_back(origin);
            myGraph.AddVertex(origin);
        }
        if (find(v, dest) == false)
        {
            v.push_back(dest);
            myGraph.AddVertex(dest);
        }

        myGraph.AddEdge(origin, dest, dist);
        cout << "The distance from " << origin << " to " << dest << " is " << myGraph.WeightIs(origin, dest) << " miles" << endl;
        //cout << "It is " << distance << " miles from " << origin << " to " << dest << endl;
        
    }
    items = v.size();
    cout << "There were " << items << " input" << endl;
    fileIn.close();
}//End readFile()

bool find(vector<string>& v, string& str)
{
    for (int i = 0; i < v.size(); i++)
        if (v[i].compare(str) == 0)
            return true;
    return false;
}//End toLowerCase()

void menu( vector<string>& v, int& items, string& begin)
{
    //char choice;
    //system("clear");
    cout << "\n\t^^^^^^^^^^^^^^^^    DIJKSTRA'S ALGORITHM    ^^^^^^^^^^^^^^^^\n\n\tA Weighted Graph Has Been Built For These " << items << " Cities: \n\n\t\t";
    printCitiesMenu(v);
    cout << endl;
    requestStart(v, begin);
}//End menu()

void dijkstraAlg(Graph<string>& myGraph, Queue<string>& myQ, vector<Node>& nodes, string& begin, int& itemNum) 
//function to run the entirety of Dijkstra's algorithm
{

}//End dijkstraAlg()

void graphToArray (Graph<string>& myGraph, vector<int> g[][], int& itemNum, vector<string>& v)
{
    for (int i = 0; i < g.size(); i++)
        for (int j = 0; j < g[i].size(); j++)
            {
                g[i][j] = myGraph.WeightIs(v[i], v[j]);
            }

    for (int i = 0; i < g.size(); i++){
        for (int j = 0; j < g[i].size(); j++)
            {
                cout << g[i][j] << " ";
            }
            cout << endl;
    }
        

}

void printCitiesMenu(vector<string>& v) //Prints the vertices nicely in the menu
{
    int temp = 0;
    for (int i = 0; i < (v.size()/3); i++)
    {
        int j = 0;
        while (j < 3)
        {
            cout << v[temp] << "\t\t";
            j++;
            temp++;
        }
        cout << "\n\t\t";

    }
    for (int k = temp+1; k <= v.size(); k++)
    {
        cout << v[temp] << "\t\t";
    } 
    cout << endl;
}//End printCitiesMenu()

void requestStart(vector<string>& v, string& begin) 
//Loop to control whether the input is valid or not for the starting point. User gets stuck her unless they put in a valid option
{
    int loop = 0;
    string start = "";
    cout << "\tPlease input your starting vertex: A Weighted Graph Has Been Built For These 7 Cities" << endl;
    do 
    {
        
        if (find(v, start) == false)
        {
            cout << "\tStarting location does not exist...\n\tPlease input a new starting vertex: ";
            cin >> start;
        }
        else{
            begin = start;
            loop = 1;
        }
    }while(loop != 1);
}//End requestStart()

void printNodes(vector<Node>& nodes) //Prints nodes from a vector of nodes
{
    cout << endl;
    for (int i = 0; i < nodes.size(); i++)
    {
        Node N = nodes[i];
        cout << "\t\t" << N.vertex << "\t\t" << N.dist << "\t\t" << N.prev << endl;
    }
    
    
}//End printNodes()

int minimumDist(vector<int>& distance, vector<bool>& TFSet, int& itemNum) //Function for finding the minimum distance
{
    int minimum = __INT_MAX__, index;

    for (int i = 0; i < itemNum; i++)
    {
        if (TFSet[i] == false && distance[i] <= minimum)
        {
            minimum = distance[i];
            index = i;
        }
    }
    return index;
}//End minimumDistance()

/*void toLowerCase(string& strIn)
{
    int i = 0;
    //char str[] = strIn;
    char c;
    while (strIn[i])
    {
        //c = strIn[i];
        strIn[i] = tolower(strIn[i]);
        i++;
    } 
}//End toLowerCase()





void options(char& command, string& fileText, HashTable& skipped, HashTable& dictionary, int& items, BinarySearchTree<BNode>& notFound)
{
        BNode bN = {fileText, items}, result = notFound.find(bN);
        string suggestion;
        switch (tolower(command))
        {
            case 'a':
                    addToDict(fileText);
                    if (result.word == "ZZZ") 
                        notFound.insert(bN);
                    break;
            case 'i':
                    skipped.insert(fileText);
                    if (result.word == "ZZZ") 
                        notFound.insert(bN);
            case 'g': 
                    break;
            case 's': 
                    //string
                    if (dictCheck(fileText, suggestion, dictionary) == true)
                    {
                        cout << "\n\tSuggested Spelling: " << suggestion << endl;
                        cout << "\n\tPlease Hit Return to Continue...";
                        cin.ignore();
                        cin.get();
                    }
                    else 
                    {
                        cout << "\n\tNo Suggested Spellings Found in Dictionary." << endl;
                        cout << "\n\tPlease Hit Return to Continue...";
                        cin.ignore();
                        cin.get();
                    }
                    if (result.word == "ZZZ") 
                        notFound.insert(bN);
                    break;
            case 'q': 
                cout << "\n\tNow Exiting program...\n" << endl;
                writeFile(notFound);
                exit(0);
            
        }
}//End optons()

void addToDict(string& addWord)
{
    string filename("dict.txt");
    ofstream file;
    file.open(filename.c_str(), std::ios::out | std::ios::app);
    if (file.is_open())
        file << addWord << endl;
    file.close();
}//End addToDict()

void writeFile(BinarySearchTree<BNode>& notFound)
{
    ofstream outfile;
    string fileName = "notfound.txt";
    
    outfile.open(fileName.c_str());
    notFound.printTree(outfile);
    //outfile.close();
}//End writeFile()

bool dictCheck(string& word, string& suggestion, HashTable& dictionary)
{
    string copy;
    char x, y, tmp;
    int i = 0;
    while (word[i])
    {
        copy = word;
        swap(copy[i], copy[i+1]);
        if (dictionary.find(copy) == true)  //If the word is found in the dictionary, make suggestion that word and return true
        {
            suggestion = copy;
            return true;
        }
        i++;
    }
    return false;
}//End dictCheck()
*/